from pydantic import BaseModel, Field, ConfigDict, field_validator
from typing import Dict, Optional


class SearchTask(BaseModel):
    """Represents a single search task generated by the Planner LLM."""
    model_config = ConfigDict(extra='ignore')
    query: str = Field(..., description="The search query string to execute.", min_length=1)
    endpoint: str = Field("/search", description="The Serper API endpoint to target (e.g., /search, /scholar).")
    num_results: int = Field(5, description="Desired number of search results.", ge=1, le=20)
    reasoning: Optional[str] = Field(None, description="Planner's reasoning for generating this specific search task.")

    @field_validator('endpoint')
    def validate_endpoint(cls, v: str) -> str:
        allowed_endpoints = ['/search', '/scholar', '/news']
        if v not in allowed_endpoints:
            raise ValueError(f"Invalid endpoint '{v}'. Allowed: {allowed_endpoints}")
        return v

class TokenUsageCounter(BaseModel):
    """Stores token counts for a specific LLM role or the total."""
    model_config = ConfigDict(frozen=True) # Make immutable

    prompt_tokens: int = 0
    completion_tokens: int = 0
    total_tokens: int = 0

class UsageStatistics(BaseModel):
    """Detailed statistics about resource usage, potentially used by multiple agencies."""
    model_config = ConfigDict(frozen=True) # Make immutable

    token_usage: Optional[Dict[str, TokenUsageCounter]] = Field(None, description="Token counts broken down by LLM role or task.")
    estimated_cost: Optional[Dict[str, float]] = Field(None, description="Estimated costs broken down by LLM role or task (USD)." )
    serper_queries_used: int = Field(..., description="Total number of calls made to the Serper Search API.")
    sources_processed_count: int = Field(..., description="Total number of unique source URLs fetched and processed.")
    refinement_iterations_run: int = Field(..., description="Number of refinement loops (search -> process -> refine) executed.") 